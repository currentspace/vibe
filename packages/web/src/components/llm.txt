# Components Directory - UI Component Library

## Overview
Reusable React components built with Chakra UI v3 and TypeScript. All components follow consistent patterns for styling, testing, and composition.

## Component Guidelines

### Structure
```typescript
// 1. Imports
import { ComponentProps } from '@chakra-ui/react'
import { useState, useEffect } from 'react'

// 2. Types/Interfaces
interface ComponentNameProps {
  // Props definition
}

// 3. Component
export function ComponentName(props: ComponentNameProps) {
  // Hooks first
  // Event handlers
  // Render
}
```

### Chakra UI v3 Patterns
- Use `Stack` with `gap` (not VStack/HStack with spacing)
- Use `loading` prop (not isLoading)
- Use `disabled` prop (not isDisabled)
- Avatar uses Avatar.Root and Avatar.Fallback
- Form controls use Field.Root, Field.Label

### Animation Patterns
```typescript
import { Global } from '@emotion/react'

const animationStyles = `
  @keyframes animationName {
    from { ... }
    to { ... }
  }
`

return (
  <>
    <Global styles={animationStyles} />
    <Box animation="animationName 0.3s ease-out">
  </>
)
```

## Component Inventory

### Button
- Wrapper around Chakra Button
- Custom variants: primary, secondary
- Maintains Chakra's props interface

### ConnectionStatus
- Real-time connection state display
- Animated status indicators (pulse, rotate)
- Shows error messages
- Displays room info when connected

### RoomManager
- Room creation and joining interface
- Form validation
- Toast notifications via createToaster
- Loading states during operations

### ParticipantList
- Displays room participants
- Animated entry/exit (slideIn, slideOut)
- Time-based "joined ago" display
- Collapsible interface
- Special "You" indicator for current user

### ClientOnly
- Prevents hydration mismatches
- Renders children only after mount
- Use for time-sensitive or browser-specific content

## State Management Patterns
- Local state with useState for UI state
- Context for shared state (WebRTC)
- Effects for subscriptions and cleanup

## Testing Approach
```typescript
// Mock context
vi.mock('@/contexts/WebRTCContext', () => ({
  useWebRTC: vi.fn(() => mockContextValue)
}))

// Render with providers
const renderWithChakra = (ui: ReactElement) => {
  return render(
    <ChakraProvider value={defaultSystem}>
      {ui}
    </ChakraProvider>
  )
}
```

## Accessibility
- Proper ARIA labels on interactive elements
- Keyboard navigation support
- Focus management in modals/overlays
- Color contrast compliance

## Performance Tips
- Use React.memo for expensive components
- Implement virtualization for long lists
- Lazy load heavy components
- Optimize re-renders with proper dependencies

## Common Pitfalls
1. **Hydration errors**: Use ClientOnly wrapper
2. **Animation issues**: Use Global styles, not css prop
3. **TypeScript errors**: Check Chakra UI v3 types
4. **Re-render loops**: Check effect dependencies

## Future Components
- VideoPlayer - WebRTC video display
- AudioControls - Mute/unmute, volume
- ScreenShare - Screen sharing controls
- ChatPanel - Text chat interface
- Settings - User preferences