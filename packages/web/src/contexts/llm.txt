# Contexts Directory - React Context Providers

## Overview
React Context providers for managing global application state. Currently contains WebRTC state management but designed to be extensible.

## WebRTCContext

### Purpose
Manages all WebRTC-related state and operations including:
- Socket.io connection to signaling server
- Peer connections
- Room management
- Connection status tracking

### State Interface
```typescript
interface WebRTCContextValue {
  // Connection state
  socket: Socket | null
  isConnected: boolean
  connectionStatus: 'disconnected' | 'connecting' | 'connected' | 'error'
  error: string | null
  
  // Room state
  currentRoom: string | null
  participants: Participant[]
  
  // Actions
  createRoom: () => Promise<string>
  joinRoom: (roomId: string) => void
  leaveRoom: () => void
}
```

### Key Features
1. **Automatic Reconnection**: Socket.io configured with reconnection
2. **Error Handling**: Captures and exposes connection errors
3. **State Synchronization**: Keeps UI in sync with connection state
4. **Cleanup**: Proper cleanup on unmount/disconnect

### Usage Pattern
```typescript
// In components
import { useWebRTC } from '@/contexts/WebRTCContext'

function MyComponent() {
  const { isConnected, joinRoom } = useWebRTC()
  // Use context values
}

// Wrap app/page
<WebRTCProvider>
  <App />
</WebRTCProvider>
```

### Socket Events Handled
- `connect`: Update connection status
- `disconnect`: Handle disconnection
- `user-joined`: Add participant
- `user-left`: Remove participant
- `room-users`: Sync participant list
- `offer/answer/ice-candidate`: WebRTC signaling

### Future Enhancements
- Add peer connection management
- Media stream handling
- Connection quality monitoring
- Reconnection with state recovery

## Context Best Practices

### Provider Placement
- Place providers as low as possible in tree
- Avoid wrapping entire app if not needed
- Consider code splitting for heavy contexts

### Performance
```typescript
// Memoize context value
const value = useMemo(() => ({
  // state and actions
}), [dependencies])

// Split contexts if needed
<AuthProvider>
  <WebRTCProvider>
    <UIProvider>
```

### Testing
```typescript
// Create test wrapper
const TestWrapper = ({ children }) => (
  <WebRTCProvider>
    {children}
  </WebRTCProvider>
)

// Mock context
vi.mock('@/contexts/WebRTCContext', () => ({
  useWebRTC: () => mockValue
}))
```

### Error Boundaries
Consider wrapping providers with error boundaries for resilience.

## Future Contexts

### UserContext
- User authentication state
- Profile information
- Preferences

### MediaContext
- Camera/microphone state
- Screen sharing
- Media constraints

### ChatContext
- Message history
- Typing indicators
- Message sending

### SettingsContext
- User preferences
- Device selection
- Quality settings

## Anti-patterns to Avoid
1. **Over-using context**: Not everything needs to be global
2. **Large context objects**: Split into focused contexts
3. **Frequent updates**: Use local state for rapid changes
4. **Missing memoization**: Always memoize context values